类型模板全特化_全特化类模板_全特化类成员函数
```c++
#include<iostream>
#include<cstdlib>
#include<string>
#include<vector>

using namespace std;
template<typename T,typename U>
class TC//泛化的tc类模板
{
public:
	void FunctionTest01()
	{
		cout << "泛化版本" << endl;
	}
	//构造函数
	TC()
	{
		cout << "泛化版本构造函数" << endl;
	}
};

//必须先有泛化版本，才能存在特化版本
//当T和U都为int类型，我们希望做一个特化版本--当两个参数都是int，系统执行我们的特化版本函数
//全特化：所有的类型模板参数，T U都用具体的类型代表
template<>//全特化，都用int代表
class TC<int,int>
{//上面泛化版本的T U参数分别对应这里的int   int
	//这里可以对特化版本做操作
public:
	void FunctionTest01()
	{
		cout << "int int 特化版本版本" << endl;
	}
	
};


template<>//全特化，都用double代表
class TC<double,int>
{//上面泛化版本的T U参数分别对应这里的int   int
 //这里可以对特化版本做操作
public:
	void FunctionTest01()
	{
		cout << "double int 特化版本版本" << endl;
	}

};



template<>//全特化
void TC<double,double>::FunctionTest01()
{
	cout << "double doubel FunctionTest01特化版本版本" << endl;
}


int main(void)
{
	//特化版本代码，编译器会优先选择
	TC<char, int>tchar;
	tchar.FunctionTest01();//调用泛化版本

	TC<int, int>tint;
	tint.FunctionTest01();//调用int,int 特化版本

	TC<double, int>tdouble;
	tdouble.FunctionTest01();//调用double int版本


	//特化成员函数，而不是类模板
	TC<double, double>tdooo;
	tdooo.FunctionTest01();//调用全特化的成员函数

	system("pause");
	return 0;
}

/*
*(1)特化---泛化
*泛化--可以随便指定类型
*特化--对特殊的类型模板参数进行特殊对待，给它写适合它的专用代码
*	类模板全特化
*		1.常规全特化
*		2.特化成员函数，而不是模板
*特化版本可以任意多。
*--------------------------------------------------------
*泛化版本构造函数
泛化版本
int int 特化版本版本
double int 特化版本版本
泛化版本构造函数
double doubel FunctionTest01特化版本版本
请按任意键继续. . .
*
*(3)
*
*
*/
```

类型模板偏特化_局部特化_模板参数数量上
```c++
#include<iostream>
#include<cstdlib>
#include<string>
#include<vector>

using namespace std;

template<typename T, typename U,typename W>
class TC//泛化的tc类模板
{
public:
	void FunctionTest01()
	{
		cout << "泛化版本" << endl;
	}
	//构造函数
	TC()
	{
		cout << "泛化版本构造函数" << endl;
	}
};

//模板参数数量--偏特化，2个参数特化
template< typename U>//T W绑定到具体的类型
class  TC<int,U,int>
{
public:
	void FunctionTest01()
	{
		cout << "数量--偏特化版本化版本" << endl;
	}
};




int main(void)
{
	
	TC<double, double, double> tcddd;
	tcddd.FunctionTest01();//调用泛化版本
	TC<int, double, int >tcidi;
	tcidi.FunctionTest01();//调用数量--偏特化版本


	
	system("pause");
	return 0;
}

/*
*(1)类型模板偏特化--也叫局部特化
*	1.模板参数数量上
*
*(3)
*
*
*/
```

局部特化_范围上

```c++
#include<iostream>
#include<cstdlib>
#include<string>
#include<vector>

using namespace std;

template<typename T>
class TC
{
public:
	void FunctionTest()
	{
		cout << "调用泛化版本函数" << endl;
	}
};

//范围特化版本  const
template<typename T>
class TC<const T>
{
public:
	void FunctionTest()
	{
		cout << "Const T特化版本" << endl;
	}
};

//范围特化版本  T*
template<typename T>
class TC<const T*>
{
public:
	void FunctionTest()
	{
		cout << "T*特化版本" << endl;
	}
};


//范围特化版本--左值引用
template<typename T>
class TC<const T&>
{
public:
	void FunctionTest()
	{
		cout << "T&特化版本" << endl;
	}
};

//范围特化版本--右值引用
template<typename T>
class TC<const T&&>
{
public:
	void FunctionTest()
	{
		cout << "T&&特化版本" << endl;
	}
};

int main(void)
{
	TC<double>td;
	td.FunctionTest();//调用泛化版本

	TC<double*>tdp;
	tdp.FunctionTest();//调用泛化版本

	TC<const double> tcc;
	tcc.FunctionTest();//调用const特化版本
	
	TC<int&>ti;
	ti.FunctionTest();//调用泛化版本


	TC<int&&>tii;
	tii.FunctionTest();//调用泛化版本
	
	system("pause");
	return 0;
}

/*
*(1)
*模板参数范围上  int --特化一个const int  大--小
*		从T缩小为T*
*		从T缩小为T& T&&
*		这种豆角范围缩小
*(2)局部特化，特化完毕还是个类模板，因为里面包含类型参数T。
*全特化完毕后里面不包含类型参数T
* Sunrise于东北电力大学第二教学楼1121实验室
* 2019年11月25日15:50:32
*
*(3)
*
*
*/
```

函数模板全特化

```c++
#include<iostream>
#include<cstdlib>
#include<string>
#include<vector>

using namespace std;


template<typename T,typename U>
void TestFunction(T &t,U&u)
{
	cout << "--这是函数泛化版本--" << endl;
}

//全特化版本 t=int，u=doubel
template<>//全特化，所以为空
void TestFunction(int &t, double&u)
{
	cout << "--这是int double类型的特化版本--" << endl;
}


void TestFunction(int &t, double&u)
{
	cout << "这是testFunction的重载函数" << endl;
}

int main(void)
{
	//函数模板全特化
	const char*p = "jisuanjiz";
	int i = 1200;
	TestFunction(p, i);//t=const char* &
	

	double d = 23.344;
	TestFunction(i, d);//调用int double 的特化版本
	//如果有重载函数，优先调用重载函数，而不去调用特例话的函数

	system("pause");
	return 0;
}

/*
*(1)函数模板全特化
*全特化函数实际山等价于实例化一个函数模板，并不是等价于一个函数重载
*
*特化函数遇上重载函数优先调用哪一个？？？
*
*(2)
*
*(3)
*
*
*/
```

函数模板不能偏特化

```c++
#include<iostream>
#include<cstdlib>
#include<string>
#include<vector>

using namespace std;


template<typename T, typename U>
void TestFunction(T &t, U&u)
{
	cout << "--这是函数泛化版本--" << endl;
}

//全特化版本 t=int，u=doubel
template<typename T>//这种写法是只有一个类型参数的新的模板，不是局部偏特化
void TestFunction(T&t, double&u)
{
	cout << "--这是局部偏特化的特化版本--" << endl;
}




int main(void)
{
	//函数模板全特化
	const char*p = "jisuanjiz";
	int i = 1200;
	TestFunction(p, i);//t=const char* &


	double d = 23.344;

	TestFunction(i, d);//重新调用了新的类型模板，而不是函数偏特化
	TestFunction(p, d);

	system("pause");
	return 0;
}

/*
*(1)函数模板偏特化--
*函数模板不能偏特化

*(2)模板特化版本 放置位置建议
*模板定义、实现一般放在.h文件中，模板的特化版本和泛化版本应该在同一文件中。
*
*返还版本在前，特化版本在后
*
*(3)
*
*
*/
```